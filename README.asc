Summary of Changes
-----------------

This project aims to extend RowCache of Cassandra with CAPI-Flash.

By adding a JVM argument, a new RowCache CAPI-RowCache is enabled. 
All of cached data is stored in large space of http://www-03.ibm.com/systems/storage/flash[IBM FlashSystem] 
through high-performance device https://www.ibm.com/developerworks/community/blogs/fe313521-2e95-46f2-817d-44a4f27eba32/entry/power8_capi_flash_in_memory_expansion_to_speed_data_access[CAPI-Flash].

CAPI-Flash
----------

CAPI-Flash provides high throughput and low latency for accessing storage.
With the help of POWER8's http://www-304.ibm.com/webapp/set2/sas/f/capi/home.html[CAPI] (Coherent Accelerator Processor Interface) capability, a CAPI-Flash card can directly access memory that POWER8 processors use.
Thus, data exchanges between memory and storage are simplified and optimized.
In addition, libraries of CAPI-Flash doesn't require kernel processing.
No kernel intervention also reduces overheads to access storage.

How to build
------------

CAPI-RowCache uses capiblock.jar and libcapiblock.so, which are not published. 
In other words, to build this project, users need to contact IBMers for these library.

OpenJDK 1.7 (or the later) is required.

  $ git clone https://github.com/hhorii/cassandra.git #clone this project
  $ cd cassandra #go to the project directory
  $ cp CAPIBLOCK_DIR/capiblock.jar CAPIBLOCK_DIR/libcapiblock.so lib/ #copy the libraries
  $ JAVA_TOOL_OPTIONS=-Dfile.encoding=UTF8 ant #build the project

How to run
----------

To run cassandra with CAPI-RowCache, the following three configurations are necessary.

 * LD_LIBRARY_PATH must include the directory of capi libraries (Usually, the directory is /opt/ibm/capikv/lib).
 * java.library.path must include the directory of CASSANDRA_HOME/lib to load libcapiblock.so.
 * JVM arguments must include CAPI-RowCache parameters.
   * rowcache.type=capi
   * capi.cell=GB_FOR_BUCKETS_IN_CACHE
   * capi.devices=DEVICE_PATH:START_LBA:GB_FOR_CACHE[:DEVICE_PATH[,DEVICE_PATH]][,DEVICE_PATH:START_LBA:GB_FOR_CACHE[:DEVICE_PATH[,DEVICE_PATH]]]
   * capi.init=true|false
   * (optional)capi.hash=CLASS_NAME

For the first use of CAPI-RowCache, **capi.init** must be **true** to initialize CAPI-RowCache.

CAPI-RowCache is a simple HashMap that has buckets. In one bucket, key and value and a pointer to the next entry with the same [hashkey % #buckets]. 
One bucket is 4KB and if 4KB is not enough to store key and value, they are stored in another space.
**capi.cell** specifies the size of the buckets. The larger capi.cell will improve performance.

**capi.devices** specifies CAPI-Flash device paths. For example, capi.devices=/dev/sg7:0:512 configures 512GB of /dev/sg7 from LBA 0. 
If /dev/sg8 and /dev/sg9 share the same LBA space with /dev/sg7, you can use them as capi.devices=/dev/sg7:0:512:/dev/sg8:/dev/sg9.
To use multiple CAPI device paths that don't share LBA spaces, you can list them as capi.devices=/dev/sg7:0:512:/dev/sg8:/dev/sg9,/dev/sg15:0:512:/dev/sg16:/dev/sg17.

**capi.hash** optimizes CAPI-RowCache by generating application-unique cache function. 
See https://github.com/hhorii/cassandra/blob/cassandra-2.1-capirowcache/src/java/org/apache/cassandra/cache/capi/YCSBKeyHashFunction.java[YCSBKeyHashFunction.java] for the example that for YCSB.

Example to run YCSB with CAPI-RowCache
--------------------------------------

Here is an example of a command to start cassandra with 512GB (256GB for buckets) for YCSB.

  $ cd $CASSANDRA_HOME
  $ LD_LIBRARY_PATH=/opt/ibm/capikv/lib JVM_OPTS="-Djava.library.path=lib/ -Drowcache.type=capi -Dcapi.devices=/dev/sg7:0:512 -Dcapi.cell=256 -Dcapi.init=true -Dcapi.hash=org.apache.cassandra.cache.capi.YCSBKeyHashFunction" $CASSANDRA_HOME/bin/cassandra #start with CAPI-RowCache


  